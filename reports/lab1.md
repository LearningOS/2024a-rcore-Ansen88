# 报告 —— chapter3练习

## 报告人 ：安利军



## 简单总结你实现的功能

本章作业实现了三个功能：

+ 获取当前任务的状态：
+ 获取当前任务的系统统计
+ 获取当前任务的运行时间

在任务控制块中增加需要的统计记录字段：系统调用的统计数组以及运行的开始时间。

***在系统调用的入口函数中增加对当前任务的对应系统调用的统计：***

1. 在任务控制块中设置一个数组；
2. 数组中的每个元素对应一个系统调用的统计；
3. 每进入系统调用的入口一次，就在当前任务的对应的系统调用统计位置加 1

***运行时间***

1. 在任务控制块中设置一个程序开始运行时间的字段；
2. 当执行获取系统调用时刻距离任务第一次被调度时刻的系统调用时，通过获取当前时间与开始时间的差值来得到运行时间；

***获取当前的任务状态***

任务控制块中包含有当前任务的状态信息，可以直接获取

## 完成问答题

***第一题***

rustsbi 的版本:

RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0



 如果正确进入 U 态后，程序的特征还有：使用 S 态特权指令，访问 S 态寄存器后会报错。执行代码中的三个 bad 测例 (ch2b_bad_*.rs)会提示如下错误：

```shell
[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003a4, kernel killed it. 
[kernel] IllegalInstruction in application, kernel killed it.
```

从启动信息可以看出 rustsbi 的地质范围是 0x80000000..0x88000000——该地址受 物理内存保护（PMP）机制的 保护，所以当在用户态对这些地址进行操作时，会产生错误异常。

sstatus寄存器是 S 模式和 M 模式下才有的寄存器，在 U 模式下访问会产生错误异常。



***第二题***

1. 刚进入 `__restore` 时，a0 中保存的值为 trap_handler() 函数的返回值，即 trap context 实际是内核栈的栈顶。`__restore` 的两种使用情景：在内核态返回用户态时被调用和在调度切换后返回用户态时被调用；
2. L43-L48 这几行代码用于恢复 sstatus、 sepc 和 sscratch 寄存器的值： 
   + sstatus保存了进入到 trap 之前的特权信息；
   + sepc保存了进入 trap 发生之前的最后一条指令的地址；
   + sscratch中保存了用户栈；
3. L50-L56 跳过了x2 和 x4：
   + x2 寄存器，在后面指向的是内核栈
   + x4 寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到。
4. L60：该指令之后，`sp` 指向用户栈 `sscratch` 指向内核栈；
5. `__restore`：中发生状态切换在 `sret`指令，该指令会恢复 `sstatus` 中的特权级；
6. L13：该指令之后，`sp` 指向内核栈 `sscratch` 指向用户栈；
7. 从 U 态进入 S 态是 ecall 指令之后发生的。



## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我没有与其他人就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容。

   

2. 此外，我未参考了任何资料，还在代码中对应的位置以注释形式记录了具体的参考来源及内容。

   

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计
